#include "main.h"
#include "socket_serial.h"
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/un.h>
#include <sys/select.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>

#define BUFFER_SIZE 2048
#define SOCKET_PATH "/dev/serial-socket"
#define MAX_CLIENTS 8
struct termios tty;

char *serialPort = "/dev/ttyUSB0";
int main()
{
    // Open serial port
    int serial_fd = open(serialPort, O_RDWR | O_NOCTTY | O_SYNC);
    if (serial_fd < 0)
    {
        perror("Serial port open error");
        return -1;
    }
    setupTermios(serial_fd);

    // Create Unix domain socket
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock == -1)
    {
        perror("socket");
        close(serial_fd);
        return -1;
    }

    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    unlink(SOCKET_PATH);

    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1)
    {
        perror("bind");
        close(sock);
        close(serial_fd);
        return -1;
    }

    if (listen(sock, MAX_CLIENTS) == -1)
    {
        perror("listen");
        close(sock);
        close(serial_fd);
        return -1;
    }

    printf("Serial bridge listening on %s\n", SOCKET_PATH);
    printf("Serial port: /dev/ttyUSB0\n");

    int clients[MAX_CLIENTS];
    for (int i = 0; i < MAX_CLIENTS; i++)
    {
        clients[i] = -1;
    }

    char buffer[BUFFER_SIZE];

    while (1)
    {
        fd_set readfds;
        FD_ZERO(&readfds);

        // Monitor serial port
        FD_SET(serial_fd, &readfds);
        int max_fd = serial_fd;

        // Monitor listening socket
        FD_SET(sock, &readfds);
        if (sock > max_fd)
            max_fd = sock;

        // Monitor all connected clients
        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (clients[i] != -1)
            {
                FD_SET(clients[i], &readfds);
                if (clients[i] > max_fd)
                    max_fd = clients[i];
            }
        }

        // Wait for activity
        struct timeval timeout = {1, 0};
        int activity = select(max_fd + 1, &readfds, NULL, NULL, &timeout);

        if (activity < 0)
        {
            perror("select error");
            break;
        }

        if (activity == 0)
            continue;

        // Check for new client connections
        if (FD_ISSET(listen_sock, &readfds))
        {
            int new_client = accept(listen_sock, NULL, NULL);
            if (new_client == -1)
            {
                perror("accept");
            }
            else
            {
                // Find empty slot for new client
                int added = 0;
                for (int i = 0; i < MAX_CLIENTS; i++)
                {
                    if (clients[i] == -1)
                    {
                        clients[i] = new_client;
                        printf("Client %d connected (fd=%d)\n", i, new_client);
                        added = 1;
                        break;
                    }
                }
                if (!added)
                {
                    printf("Max clients reached, rejecting connection\n");
                    close(new_client);
                }
            }
        }

        // Read from serial port and broadcast to all clients
        if (FD_ISSET(serial_fd, &readfds))
        {
            int n = read(serial_fd, buffer, BUFFER_SIZE);
            if (n > 0)
            {
                printf("Serial->Clients: %d bytes\n", n);

                // Broadcast to all connected clients
                for (int i = 0; i < MAX_CLIENTS; i++)
                {
                    if (clients[i] != -1)
                    {
                        int sent = write(clients[i], buffer, n);
                        if (sent <= 0)
                        {
                            printf("Client %d disconnected\n", i);
                            close(clients[i]);
                            clients[i] = -1;
                        }
                    }
                }
            }
            else if (n < 0 && errno != EAGAIN)
            {
                perror("serial read error");
            }
        }

        // Read from each client and forward to serial
        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (clients[i] != -1 && FD_ISSET(clients[i], &readfds))
            {
                int n = read(clients[i], buffer, BUFFER_SIZE);
                if (n > 0)
                {
                    printf("Client %d->Serial: %d bytes\n", i, n);
                    int sent = write(serial_fd, buffer, n);
                    if (sent < 0)
                    {
                        perror("serial write error");
                    }
                }
                else
                {
                    printf("Client %d disconnected\n", i);
                    close(clients[i]);
                    clients[i] = -1;
                }
            }
        }
    }

    // Cleanup
    for (int i = 0; i < MAX_CLIENTS; i++)
    {
        if (clients[i] != -1)
            close(clients[i]);
    }
    close(listen_sock);
    close(serial_fd);
    unlink(SOCKET_PATH);

    return 0;
}